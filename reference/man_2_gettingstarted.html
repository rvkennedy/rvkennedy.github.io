---
title: 2 Getting Started
layout: reference
url: 2 Getting Started
---
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>trueSKY: 2 Getting Started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">2 Getting Started </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The simplest approach to rendering Simul skies is to use the existing renderer classes from the Simul/Platform directory. These can be seen in action in the samples. To build the samples, use the solution file appropriate to your Visual Studio version: </p><pre class="fragment">- SimulSamples_Win32_VC10.sln
- SimulSamples_x64_VC11.sln
</pre><div class="image">
<img src="SimulOverview.png" alt="SimulOverview.png"/>
</div>
<p>The two main elements to implementing trueSKY in a project are: an Environment object, which will encapsulate sky and cloud data; a WeatherRenderer, and a RenderPlatform.</p>
<p>You should create an instance of <a class="el" href="classsimul_1_1clouds_1_1Environment.html">simul::clouds::Environment</a>, which is persistent. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &quot;Simul/LicenseKey.h&quot;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#include &quot;Simul/Base/EnvironmentVariables.h&quot;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;simul::clouds::Environment *environment=NULL;</div></div><!-- fragment --><p>Apply your trueSKY licence key (see <a class="el" href="man_a_licensing.html">Licensing</a> for more details), and initialize the Environment instance: </p><div class="fragment"><div class="line">simul::base::SetLicence(SIMUL_LICENSE_KEY);</div><div class="line">environment=<span class="keyword">new</span> <a class="code" href="classsimul_1_1clouds_1_1Environment.html">simul::clouds::Environment</a>();</div></div><!-- fragment --><p>The Environment is API-neutral, it calculates and updates environment data. We will create a persistent <a class="el" href="classsimul_1_1crossplatform_1_1RenderPlatform.html">RenderPlatform</a>, whose class depends on the graphics API we use:</p>
<div class="fragment"><div class="line"><a class="code" href="classsimul_1_1dx11_1_1RenderPlatform.html">simul::dx11::RenderPlatform</a> renderPlatformDx11;</div></div><!-- fragment --><p>The RenderPlatform classes implement platform-specific rendering functions called from a cross-platform interface. And we will create a weather renderer, which is also API-neutral: </p><div class="fragment"><div class="line"><a class="code" href="classsimul_1_1clouds_1_1BaseWeatherRenderer.html">simul::clouds::BaseWeatherRenderer</a> *weatherRenderer=<span class="keyword">new</span> <a class="code" href="classsimul_1_1clouds_1_1BaseWeatherRenderer.html">simul::clouds::BaseWeatherRenderer</a>(environment);</div></div><!-- fragment --><p>In the case of DirectX 11, we initialize the RenderPlatform with a pointer to our ID3D11Device: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> OnD3D11CreateDevice(<span class="keyword">struct</span> ID3D11Device* pd3dDevice)</div><div class="line">{</div><div class="line">    renderPlatformDx11.<a class="code" href="classsimul_1_1dx11_1_1RenderPlatform.html#a10c03f0df71173542f98f4ded231f87d">RestoreDeviceObjects</a>(pd3dDevice);</div></div><!-- fragment --><p> Having done this, we can now pass the render platform pointer to the device-specific initialization of our renderers: </p><div class="fragment"><div class="line">    weatherRenderer-&gt;<a class="code" href="classsimul_1_1clouds_1_1BaseWeatherRenderer.html#a72de865052f574a909e0700a7fb5d303">RestoreDeviceObjects</a>(&amp;renderPlatformDx11);</div><div class="line">}</div></div><!-- fragment --><p>In-game, we update the environment, usually once per frame: </p><div class="fragment"><div class="line">environment-&gt;update(time_step_days);</div></div><!-- fragment --><p>The time step is given in days - a floating point value, usually some small fraction less than one. This is the simulation time step, rather than real-time. Then to render:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Render(ID3D11DeviceContext* pContext)</div><div class="line">{</div><div class="line">    <a class="code" href="structsimul_1_1crossplatform_1_1DeviceContext.html">simul::crossplatform::DeviceContext</a> deviceContext;</div><div class="line">    deviceContext.platform_context              =pContext;</div><div class="line">    deviceContext.renderPlatform                =&amp;renderPlatformDx11;</div><div class="line">    deviceContext.viewStruct.<a class="code" href="structsimul_1_1crossplatform_1_1ViewStruct.html#ade0e1516f7ca9f589b7961a778065efc">view_id</a>            =view_id;</div><div class="line">    deviceContext.viewStruct.<a class="code" href="structsimul_1_1crossplatform_1_1ViewStruct.html#a5d5ec12b030c8335ef3fa6eb01298e77">depthTextureStyle</a>  =crossplatform::PROJECTION;</div><div class="line">    deviceContext.viewStruct.<a class="code" href="structsimul_1_1crossplatform_1_1ViewStruct.html#a185f8871592b82b9f1bc59313be364f2">view</a>               =viewMatrix;</div><div class="line">    deviceContext.viewStruct.<a class="code" href="structsimul_1_1crossplatform_1_1ViewStruct.html#a5721c77a187e62dc3f3547e32fde52b6">proj</a>               =projectionMatrix;</div></div><!-- fragment --><p> We've created a <a class="el" href="structsimul_1_1crossplatform_1_1DeviceContext.html">deviceContext</a> object that we will pass to the render functions. This object encapsulates the platform-specific context - in this case it's an ID3D11DeviceContext pointer - and view-specific information: the view and projection matrices for example.</p>
<p>There are different types of projection matrix, and some are better than others. The classic projection transforms a viewspace position into a clip position and depth value, where depth=0 is the near plane and depth=1 is the far. But this forward projection has a very inefficient distribution of depth values with respect to distance, and causes a loss of precision. Superior to this is the reverse projection, where depth=0 represents the far plane, and depth=1 the near. It's strongly recommended that you use reverse projection to get the best visual results from trueSKY. The projection matrix that you send to trueSKY should be the same one that was used to create your depth buffer.</p>
<p>Each individual view that you want to draw simultaneously on screen should have its own unique view_id. You don't have to explicitly create views, but you should call:</p>
<div class="fragment"><div class="line">weatherRenderer-&gt;<a class="code" href="classsimul_1_1clouds_1_1BaseWeatherRenderer.html#a7170fc074f1733f44941a2ec26314141">RemoveView</a>(view_id);</div></div><!-- fragment --><p>to free up GPU memory if a view is removed.</p>
<p>We specify the depth texture style so that trueSKY knows how to interpret the depth information you pass to it. The matrices (<a class="el" href="classsimul_1_1math_1_1Matrix4x4.html">Matrix4x4</a>) are row-major view and projection matrices stored as a simple block of 16 floats - you can cast from most standard matrix classes directly.</p>
<p>Once per frame, before rendering , we must call <a class="el" href="classsimul_1_1clouds_1_1BaseWeatherRenderer.html#a475e35931efc000687a8d66251e86505">PreRenderUpdate</a>, passing a deviceContext that refers to <em>main</em> <em>view</em>. </p><div class="fragment"><div class="line">weatherRenderer-&gt;<a class="code" href="classsimul_1_1clouds_1_1BaseWeatherRenderer.html#a475e35931efc000687a8d66251e86505">PreRenderUpdate</a>(deviceContext,real_time_s);</div></div><!-- fragment --><p> The parameter <em>real_time_s</em> is real time in seconds - as distinct from simulation time, which might be greatly accelerated, or change instantly, real time is used mainly for effects like rain that we might not want to appear accelerated.</p>
<p>For each view, we render the sky, passing an appropriate device context. </p><div class="fragment"><div class="line">weatherRenderer-&gt;<a class="code" href="classsimul_1_1clouds_1_1BaseWeatherRenderer.html#ae6926dd292486c1c305b73b1c5245a73">Render</a>(deviceContext,</div><div class="line">                        ,(<span class="keywordtype">bool</span>)is_cubemap</div><div class="line">                        ,(<span class="keywordtype">float</span>) exposure</div><div class="line">                        ,(<span class="keywordtype">float</span>) gamma</div><div class="line">                        ,mainDepthTexture</div><div class="line">                        ,depthViewport);</div></div><!-- fragment --><p>The <em>exposure</em> is a brightness multiplier - 1.0 is a good value, but the chosen number depends on how bright you want the sky to be relative to your scene. We can also perform <em>gamma</em> correction.</p>
<p>We use <em>is_cubemap</em> to specify whether we're doing a cubemap render. If so, shortcuts will be used to draw with less detail. We pass a depth texture, because the atmospherics and clouds need to use this. The <em>depthViewport</em> specifies what area of the texture is being used for the current view (some engines store a larger texture and use a portion of it): pass NULL here to use the entire texture. See also <a class="el" href="man_5_classes_ooo3_mixed.html">Mixed Resolution Rendering</a>.</p>
<h1>Platform considerations </h1>
<h2>DirectX 11 </h2>
<p>To use DirectX 11, build the DirectX11 platform library in Simul/Platform/DirectX11.</p>
<p>The DirectX platform library used the DirectX SDK by default, but can be recompiled from the provided source to run on the Windows 8 SDK.</p>
<p>The location of the most recent DirectX SDK on your hard drive is usually given by the DXSDK_DIR environment variable - it is usually of the form 'C:/Program Files (x86)/Microsoft DirectX SDK (June 2010)' etc.</p>
<p>To build with the Windows 8 SDK, ensure that both the DirectX11 library and the executable are using the standard toolset (e.g. v110, not v110_xp), remove the SimulDXSDK.props property sheet from the projects, then add the SimulWin8SDK.props property sheet to both projects. Rebuild Simul/Platform/DirectX11 and the executable.</p>
<p>To add True Sky to a DirectX 11 project, you need to link with the Simul core libraries, and also with the DirectX11 project. You can use the Simul property sheets - e.g. Simul/Platform/DirectX/SimulUseDXSDK.props, alternatively:</p>
<ul>
<li>In the project properties, select Configuration:All, then under "Configuration Properties, C++, General" add the following to "Additional Include Directories": <div class="fragment"><div class="line">$(SIMUL)/../;$(DXSDK_DIR)/include</div></div><!-- fragment --> The SIMUL environment variable is set by the trueSKY installer, while the DXSDK_DIR variable is set when you install DirectX.</li>
<li>Under "Configuration Properties, Linker, General" set "Additional Library Directories" to:</li>
</ul>
<div class="fragment"><div class="line">$(SIMUL)/lib/$(Platform)/VC11/$(Configuration);$(DXSDK_DIR)/Lib/x86</div></div><!-- fragment --><p> where VC11 should be replaced by VC12 etc for different Visual Studio versions, and x86 by x64 for 64-bit builds.</p>
<ul>
<li>In your initialization code, setup file loading and paths if needed, before creating the weather renderer: <div class="fragment"><div class="line">simul::dx11::SetFileLoader(myFileLoader);</div><div class="line">simul::dx11::PushShaderPath(<span class="stringliteral">&quot;my_shader_path&quot;</span>);</div><div class="line">simul::dx11::PushTexturePath(<span class="stringliteral">&quot;my_texture_path&quot;</span>);</div><div class="line">simul::dx11::SetShaderBinaryPath(<span class="stringliteral">&quot;my_binary_path&quot;</span>);</div></div><!-- fragment --> For example, the DirectX11 sample uses the default file loader, and the paths to shaders in "Simul/Platform/DirectX11/HLSL" and textures in "Simul/Media/Textures".</li>
</ul>
<h2>OpenGL </h2>
<p>In order to build the OpenGL sample you will need GLUT, and GLEW (both included in Simul/External). GLSL is used for shaders. You should build the OpenGL platform library in Simul/Platform/OpenGL.</p>
<p>To add True Sky to an OpenGL project:</p>
<ul>
<li>In the project properties, select Configuration:All, then under "Configuration Properties, C++, General" add the following "Additional Include Directories":</li>
</ul>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;$(SIMUL)/../&quot;</span>;<span class="stringliteral">&quot;$(SIMUL)/External/OpenGL/include&quot;</span>;<span class="stringliteral">&quot;$(SIMUL)/External/FreeImage/Dist&quot;</span></div></div><!-- fragment --><ul>
<li>Under "Configuration Properties, Linker, General" set "Additional Library Directories" to:</li>
</ul>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;$(SIMUL)/lib/$(PlatformName)/VC11/$(ConfigurationName)&quot;</span>;<span class="stringliteral">&quot;$(SIMUL)/External/OpenGL/lib&quot;</span>;<span class="stringliteral">&quot;$(SIMUL)/External/FreeImage/Dist&quot;</span></div></div><!-- fragment --><ul>
<li>The libraries themselves are linked automatically when the headers are included.</li>
<li>On scene initialization, initialize the shader path and the weather object:</li>
</ul>
<div class="fragment"><div class="line">simul::opengl::PushShaderPath(<span class="stringliteral">&quot;shaders/&quot;</span>);</div></div><!-- fragment --><hr/>
<p> Next: <a class="el" href="man_3_rendering.html">3 Rendering the Environment</a> </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/>
<address style="text-align: right;">trueSKY VERSION SIMUL_MAJOR_VERSION=4.0.0<small>
Fri Aug 5 2016 07:52:19</small></address>
</body>
</html>
